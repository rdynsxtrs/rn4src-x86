--- a/sysdeps/i386/i686/multiarch/init-arch.h	2009-08-01 09:04:44.000000000 +0200
+++ b/sysdeps/i386/i686/multiarch/init-arch.h	2014-08-03 21:05:11.000000000 +0200
@@ -1 +1,131 @@
-#include <sysdeps/x86_64/multiarch/init-arch.h>
+/* This file is part of the GNU C Library.
+   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define bit_Fast_Rep_String		(1 << 0)
+#define bit_Fast_Copy_Backward		(1 << 1)
+#define bit_Slow_BSF			(1 << 2)
+#define bit_Prefer_SSE_for_memop	(1 << 3)
+
+#ifdef	__ASSEMBLER__
+
+# include <ifunc-defines.h>
+
+# define bit_SSE2	(1 << 26)
+# define bit_SSSE3	(1 << 9)
+# define bit_SSE4_1	(1 << 19)
+# define bit_SSE4_2	(1 << 20)
+
+# define index_SSE2	COMMON_CPUID_INDEX_1*CPUID_SIZE+CPUID_EDX_OFFSET
+# define index_SSSE3	COMMON_CPUID_INDEX_1*CPUID_SIZE+CPUID_ECX_OFFSET
+# define index_SSE4_1	COMMON_CPUID_INDEX_1*CPUID_SIZE+CPUID_ECX_OFFSET
+# define index_SSE4_2	COMMON_CPUID_INDEX_1*CPUID_SIZE+CPUID_ECX_OFFSET
+
+# define index_Fast_Rep_String		FEATURE_INDEX_1*FEATURE_SIZE
+# define index_Fast_Copy_Backward	FEATURE_INDEX_1*FEATURE_SIZE
+# define index_Slow_BSF			FEATURE_INDEX_1*FEATURE_SIZE
+# define index_Prefer_SSE_for_memop	FEATURE_INDEX_1*FEATURE_SIZE
+
+#else	/* __ASSEMBLER__ */
+
+# include <sys/param.h>
+
+enum
+  {
+    COMMON_CPUID_INDEX_1 = 0,
+    /* Keep the following line at the end.  */
+    COMMON_CPUID_INDEX_MAX
+  };
+
+enum
+  {
+    FEATURE_INDEX_1 = 0,
+    /* Keep the following line at the end.  */
+    FEATURE_INDEX_MAX
+  };
+
+extern struct cpu_features
+{
+  enum cpu_features_kind
+    {
+      arch_kind_unknown = 0,
+      arch_kind_intel,
+      arch_kind_amd,
+      arch_kind_other
+    } kind;
+  int max_cpuid;
+  struct cpuid_registers
+  {
+    unsigned int eax;
+    unsigned int ebx;
+    unsigned int ecx;
+    unsigned int edx;
+  } cpuid[COMMON_CPUID_INDEX_MAX];
+  unsigned int family;
+  unsigned int model;
+  unsigned int feature[FEATURE_INDEX_MAX];
+} __cpu_features attribute_hidden;
+
+
+extern void __init_cpu_features (void) attribute_hidden;
+#define INIT_ARCH()\
+  do							\
+    if (__cpu_features.kind == arch_kind_unknown)	\
+      __init_cpu_features ();				\
+  while (0)
+
+/* Used from outside libc.so to get access to the CPU features structure.  */
+extern const struct cpu_features *__get_cpu_features (void)
+     __attribute__ ((const));
+
+# ifndef NOT_IN_libc
+#  define __get_cpu_features()	(&__cpu_features)
+# endif
+
+# define HAS_CPU_FEATURE(idx, reg, bit) \
+  ((__get_cpu_features ()->cpuid[idx].reg & (1 << (bit))) != 0)
+
+/* Following are the feature tests used throughout libc.  */
+
+# define HAS_SSE2	HAS_CPU_FEATURE (COMMON_CPUID_INDEX_1, edx, 26)
+# define HAS_POPCOUNT	HAS_CPU_FEATURE (COMMON_CPUID_INDEX_1, ecx, 23)
+# define HAS_SSSE3	HAS_CPU_FEATURE (COMMON_CPUID_INDEX_1, ecx, 9)
+# define HAS_SSE4_1	HAS_CPU_FEATURE (COMMON_CPUID_INDEX_1, ecx, 19)
+# define HAS_SSE4_2	HAS_CPU_FEATURE (COMMON_CPUID_INDEX_1, ecx, 20)
+# define HAS_FMA	HAS_CPU_FEATURE (COMMON_CPUID_INDEX_1, ecx, 12)
+
+# define index_Fast_Rep_String		FEATURE_INDEX_1
+# define index_Fast_Copy_Backward	FEATURE_INDEX_1
+# define index_Slow_BSF			FEATURE_INDEX_1
+# define index_Prefer_SSE_for_memop	FEATURE_INDEX_1
+
+#define HAS_ARCH_FEATURE(idx, bit) \
+  ((__get_cpu_features ()->feature[idx] & (bit)) != 0)
+
+#define HAS_FAST_REP_STRING \
+  HAS_ARCH_FEATURE (index_Fast_Rep_String, bit_Fast_Rep_String)
+
+#define HAS_FAST_COPY_BACKWARD \
+  HAS_ARCH_FEATURE (index_Fast_Copy_Backward, bit_Fast_Copy_Backward)
+
+#define HAS_SLOW_BSF \
+  HAS_ARCH_FEATURE (index_Slow_BSF, bit_Slow_BSF)
+
+#define HAS_PREFER_SSE_FOR_MEMOP \
+  HAS_ARCH_FEATURE (index_Prefer_SSE_for_memop, bit_Prefer_SSE_for_memop)
+
+#endif	/* __ASSEMBLER__ */
--- a/sysdeps/i386/i686/multiarch/init-arch.c	2009-09-03 16:33:58.000000000 +0200
+++ b/sysdeps/i386/i686/multiarch/init-arch.c	2014-08-03 21:05:11.000000000 +0200
@@ -1 +1,129 @@
-#include <sysdeps/x86_64/multiarch/init-arch.c>
+/* Initialize CPU feature data.
+   This file is part of the GNU C Library.
+   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+   Contributed by Ulrich Drepper <drepper@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <atomic.h>
+#include <cpuid.h>
+#include "init-arch.h"
+
+
+struct cpu_features __cpu_features attribute_hidden;
+
+
+static void
+get_common_indeces (unsigned int *family, unsigned int *model)
+{
+  __cpuid (1, __cpu_features.cpuid[COMMON_CPUID_INDEX_1].eax,
+	   __cpu_features.cpuid[COMMON_CPUID_INDEX_1].ebx,
+	   __cpu_features.cpuid[COMMON_CPUID_INDEX_1].ecx,
+	   __cpu_features.cpuid[COMMON_CPUID_INDEX_1].edx);
+
+  unsigned int eax = __cpu_features.cpuid[COMMON_CPUID_INDEX_1].eax;
+  *family = (eax >> 8) & 0x0f;
+  *model = (eax >> 4) & 0x0f;
+}
+
+
+void
+__init_cpu_features (void)
+{
+  unsigned int ebx;
+  unsigned int ecx;
+  unsigned int edx;
+  unsigned int family = 0;
+  unsigned int model = 0;
+  enum cpu_features_kind kind;
+
+  __cpuid (0, __cpu_features.max_cpuid, ebx, ecx, edx);
+
+  /* This spells out "GenuineIntel".  */
+  if (ebx == 0x756e6547 && ecx == 0x6c65746e && edx == 0x49656e69)
+    {
+      kind = arch_kind_intel;
+
+      get_common_indeces (&family, &model);
+
+      /* Intel processors prefer SSE instruction for memory/string
+	 routines if they are avaiable.  */
+      __cpu_features.feature[index_Prefer_SSE_for_memop]
+	|= bit_Prefer_SSE_for_memop;
+
+      unsigned int eax = __cpu_features.cpuid[COMMON_CPUID_INDEX_1].eax;
+      unsigned int extended_family = (eax >> 20) & 0xff;
+      unsigned int extended_model = (eax >> 12) & 0xf0;
+      if (family == 0x0f)
+	{
+	  family += extended_family;
+	  model += extended_model;
+	}
+      else if (family == 0x06)
+	{
+	  model += extended_model;
+	  switch (model)
+	    {
+	    case 0x1c:
+	    case 0x26:
+	      /* BSF is slow on Atom.  */
+	      __cpu_features.feature[index_Slow_BSF] |= bit_Slow_BSF;
+	      break;
+
+	    case 0x1a:
+	    case 0x1e:
+	    case 0x1f:
+	    case 0x25:
+	    case 0x2c:
+	    case 0x2e:
+	    case 0x2f:
+	      /* Rep string instructions and copy backward are fast on
+		 Intel Core i3, i5 and i7.  */
+#if index_Fast_Rep_String != index_Fast_Copy_Backward
+# error index_Fast_Rep_String != index_Fast_Copy_Backward
+#endif
+	      __cpu_features.feature[index_Fast_Rep_String]
+		|= bit_Fast_Rep_String | bit_Fast_Copy_Backward;
+	      break;
+	    }
+	}
+    }
+  /* This spells out "AuthenticAMD".  */
+  else if (ebx == 0x68747541 && ecx == 0x444d4163 && edx == 0x69746e65)
+    {
+      kind = arch_kind_amd;
+
+      get_common_indeces (&family, &model);
+    }
+  else
+    kind = arch_kind_other;
+
+  __cpu_features.family = family;
+  __cpu_features.model = model;
+  atomic_write_barrier ();
+  __cpu_features.kind = kind;
+}
+
+#undef __get_cpu_features
+
+const struct cpu_features *
+__get_cpu_features (void)
+{
+  if (__cpu_features.kind == arch_kind_unknown)
+    __init_cpu_features ();
+
+  return &__cpu_features;
+}
